//codigo usuario
package backend.analizador.comprobaciones.tablasimbolos;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.Stack;
import backend.analizador.objetos.*;


//Codigo para el parser, variables, metodos
parser code
{:
    //codigo
    //public ArrayList<ErrorSintactico> listaErrores = new ArrayList<>();

    public void setAccion(String tipo, String mensaje, String accion){
    }

	private Symbol s;
	public Symbol getS(Symbol s){
        return this.s = s;
    }

    public void syntax_error(Symbol s){
        String message = s.toString();
        StringBuilder m = new StringBuilder("Error: ");
        String cadena =  (String) s.value;
        int columna = s.left+1;
        int linea = s.right+1;
        agregarError("Sintactico",cadena,"No se esperaba un token tipo <"+s.value+">", linea, columna);
    }

	public void agregarError(String tipo, String cadena, String descripcion, int linea, int columna){
        System.out.println("Tipo: "+tipo+"\tCadena: "+cadena+", descripcion: "+descripcion+", Linea: "+linea+", Columna: "+columna);
    }


	public void unrecovered_syntax_error(Symbol cur_token){
        
        System.out.println("No se pudo recuperar y seguir analizando, no se encontraron mas tokens.");
    }

:}

//Coidgo para las acciones gramaticales

action code
{:
	public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public ManejadorTablaSimbolos manejadorTablaSimbolos = new ManejadorTablaSimbolos(tablaSimbolos);
	public ComprobacionTipos comprobacionTipos = new ComprobacionTipos();
	public ManejadorArreglos manejadorArreglos = new ManejadorArreglos();
	boolean reportar = true;
:}

//Declaraciones 
//terminal COMENTARIO_LINEA, COMENTARIO_BLOQUE;
terminal PISTA;
terminal String IDENTIFICADOR;
terminal EXTIENDE, COMA, PUNTO_COMA;
terminal ENTERO, DOBLE, BOOLEAN, CARACTER_RSV, CADENA_RSV;
terminal IGUAL_IGUAL, DIFERENTE, MAYOR_Q, MENOR_Q, MAYOR_IGUAL, MENOR_IGUAL, IS_NULL;
terminal AND, NAND, OR, NOR, XOR, NOT;
terminal MAS, MENOS, POR, DIVISION, MODULO, POTENCIA;
terminal KEEP, VAR, IGUAL;
terminal Integer NUMERO;
terminal Double DECIMAL;
terminal String CADENA;
terminal Boolean TRUE, FALSE;
terminal String CARACTER;
terminal MAS_IGUAL, MAS_MAS, MENOS_MENOS;
terminal ARREGLO, CORCHETE_A, CORCHETE_C, LLAVE_A, LLAVE_C;
terminal SI, SINO, PA_A, PA_C;
terminal SWITCH, CASO, SALIR, DEFAULT;
terminal PARA, MIENTRAS, HACER, CONTINUAR;
terminal RETORNAR, VOID;
terminal REPRODUCIR, ESPERAR, ORDENAR, ASCENDENTE, DESCENDENTE, PARES, IMPARES, PRIMOS;
terminal SUMARIZAR, LONGITUD, MENSAJE, PRINCIPAL;
terminal DO, RE, MI, FA, SOL, LA, DO_S, RE_S, FA_S, SOL_S, LA_S, SINO_SI;
terminal INDENT, DEDENT;


// declaracion no terminales
//non terminal String INICIO, blanco, comentarios, codigo, struct_pista, struct_extiende;
non terminal  INICIO, blanco, codigo, struct_pista, struct_extiende;
non terminal  extiende_state, struc_code, struct_declaracion_var;
non terminal Boolean keep_state;
non terminal  valor_declaracion_operacion;
non terminal Simbolo valor, struc_asig_var;
non terminal String tipo_dato;
non terminal Simbolo struct_operador_logico;
non terminal Simbolo valor_operacion;
non terminal struct_declaracion_array;
non terminal  dim_arreglo, valor_arreglo, valores_array;
non terminal  struct_si, struct_sino, struct_switch;
non terminal  state_tab, struct_asig_arreglo;
non terminal  struct_para, struct_mientras;
non terminal  struct_hacer, struct_funcion, struct_procedimiento, struct_reproducir;
non terminal  struct_esperar, struct_ordenar, struct_sumarizar, struct_longitud;
non terminal  struct_mensaje, struct_principal;
non terminal  strunt_llamada_funcion, struct_llamada_arreglo;
non terminal ArrayList<Simbolo> parametros, state_params;
non terminal  para_asig_var, condicion_para, incremento_para, struct_parametros;
non terminal  notas, tipo_orden, struct_operador_relacional;
non terminal  tipo_valor_op_logico, mensajes;
non terminal  st_ind, st_ded, st_final, code_funcion, code_metodo, caso_salir, state_continuar, struct_caso ;
non terminal params_lleno, param_vacio, valores_array_mas_dim, especiales_q_retornan;
non terminal state_op_logicos, state_op_racional;
non terminal struct_declaracion_var_f, struct_declaracion_array_f;
/*non terminal ;
*/


//presedencia de menor a mayor
//Precediencia operadores logicos
precedence left OR, NOR, XOR;
precedence left AND, NAND;
precedence right NOT;

//Presedencia operadores matematicos
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR_Q, MENOR_Q, MAYOR_IGUAL, MENOR_IGUAL;
precedence left MAS, MENOS;
precedence left MODULO, DIVISION, POR;
precedence left POTENCIA;



start with INICIO;

//Reglas Semanticas


INICIO ::= blanco codigo;

/*------------------------------------------------------------------------------LO QUE VENGA AL INICIO*/
// blanco ::= 	 comentarios blanco
// 			|INDENT blanco DEDENT blanco
//             |;

blanco ::= 	 INDENT blanco DEDENT blanco
            |;

/*------------------------------------------------------------------------------ESTADOS DE INDENT y DEDENT*/

st_ind ::=   INDENT {:manejadorTablaSimbolos.indent();:};

st_ded ::=   DEDENT {:manejadorTablaSimbolos.dedent();:};

st_final ::= DEDENT
            |;

/*------------------------------------------------------------------------------COMENTARIOS*/

// comentarios ::=  COMENTARIO_LINEA
// 				|COMENTARIO_BLOQUE;

/*------------------------------------------------------------------------------CODIGO PISTA*/
codigo ::= 	 struct_pista codigo
            |;

/*------------------------------------------------------------------------------ESTRUCTURA DE PISTA*/

struct_pista ::= 
	 PISTA IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,"PISTA",manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.isExistSimbolo(s)){
					manejadorTablaSimbolos.agregarSimbolo(s);
				}else{
					parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
				}
	:} extiende_state st_ind struc_code st_final;

/*------------------------------------------------------------------------------ESTADO EXTIENDE O NO*/

extiende_state ::= 	 struct_extiende
					|;

/*------------------------------------------------------------------------------ESTRUCTURA EXTIENDE*/

struct_extiende ::=  struct_extiende COMA IDENTIFICADOR
					|EXTIENDE IDENTIFICADOR;

struc_code ::=	 struct_declaracion_var struc_code
				|struct_declaracion_array  struc_code
                |struct_funcion struc_code
                |struct_procedimiento struc_code
                |struct_principal struc_code
				|;

/*------------------------------------------------------------------------------ESTRUCTURA DE DECLARACION DE VARIABLES*/

struct_declaracion_var ::=	 
	 struct_declaracion_var:ss COMA IDENTIFICADOR:a {:
				Simbolo sAux =(Simbolo) ss;
				Simbolo s = new Simbolo(a,sAux.getTipo(),manejadorTablaSimbolos.ambitoFlag,sAux.isIsKeep());
				if(reportar){
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				
				RESULT = s;
	:}
	|struct_declaracion_var:r COMA IDENTIFICADOR:a IGUAL struct_operador_logico:vr {:
				Simbolo s = null;
				Simbolo sr1 = (Simbolo) r;
				Simbolo sr = (Simbolo) vr;
				if(reportar && vr!=null){
					s = new Simbolo(a,sr1.getTipo(),manejadorTablaSimbolos.ambitoFlag,sr1.isIsKeep());
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(comprobacionTipos.getTipoDato(sr1.getTipo(),sr.getTipo())!=null ){
							s.setObjeto(comprobacionTipos.convertir(vr.getObjeto(),sr.getTipo()));
							manejadorTablaSimbolos.agregarSimbolo(s);
						}else{
							parser.agregarError("Semantico",a,"Error: no es posible asignar el valor a la varible nombre \""+a+"\", ya que no es del mismo tipo dato", vrright+1, vrleft+1);
						}
						
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				RESULT = s;
	:}
	|keep_state:k VAR tipo_dato:t IDENTIFICADOR:a IGUAL struct_operador_logico:vr {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,k);
				Simbolo sr = (Simbolo) vr;
				if(reportar && vr!=null){
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(comprobacionTipos.getTipoDato(s.getTipo(),sr.getTipo())!=null ){
							s.setObjeto(comprobacionTipos.convertir(sr.getObjeto(),sr.getTipo()));
							manejadorTablaSimbolos.agregarSimbolo(s);
						}else{
							parser.agregarError("Semantico",a,"Error: no es posible asignar el valor a la varible nombre \""+a+"\", ya que no es del mismo tipo dato", vrright+1, vrleft+1);
						}
						
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				RESULT = s;
	:}
	|keep_state:k VAR tipo_dato:t IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,k);
				if(reportar){
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				RESULT = s;
	:};

struct_declaracion_var_f ::=	 
	 struct_declaracion_var_f COMA IDENTIFICADOR
	|struct_declaracion_var_f COMA IDENTIFICADOR IGUAL struct_operador_logico
	|VAR tipo_dato IDENTIFICADOR IGUAL struct_operador_logico
	|VAR tipo_dato IDENTIFICADOR;

/*------------------------------------------------------------------------------ESTADO KEEP*/

keep_state ::=   KEEP {:RESULT = true;:}
                | {:RESULT = false;:};

/*------------------------------------------------------------------------------VALORES DE DATOS*/

valor ::=	 
	 IDENTIFICADOR:a {:
	 			Simbolo s = new Simbolo(a,manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.buscarSimbolo(s)){
					s = manejadorTablaSimbolos.getSimbolo();
					RESULT = s;
				}else{
					if(reportar){
						parser.agregarError("Semantico",a,"Error: No existe un simbolo con el nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					
				}
	:}
	|strunt_llamada_funcion:r {:RESULT = (Simbolo) r;:}
	|struct_llamada_arreglo:r {:RESULT = (Simbolo) r;:}
	|especiales_q_retornan:r {:RESULT = (Simbolo) r;:}
	|NUMERO:a {:
			Simbolo s = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(Integer)a);
			RESULT = s;
	:}
	|DECIMAL:a {:
			Simbolo s = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(Double)a);
			RESULT = s;
	:}
	|CADENA:a {:
			Simbolo s = new Simbolo("CADENA","CADENA",manejadorTablaSimbolos.ambitoFlag,(String)a);
			RESULT = s;
	:}
	|CARACTER:a {:
			Simbolo s = new Simbolo("CARACTER","CARACTER",manejadorTablaSimbolos.ambitoFlag,a);
			RESULT = s;
	:}
	|TRUE {:
			Simbolo s = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag,true);
			RESULT = s;
	:}
	|FALSE {:
			Simbolo s = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag,false);
			RESULT = s;
	:};

strunt_llamada_funcion ::= 
	 IDENTIFICADOR:a PA_A state_params:p PA_C {:
	 			Simbolo s = new Simbolo(a,manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.buscarSimboloFuncionMetodo(s,"FUNCION")){
					s = manejadorTablaSimbolos.getSimbolo();
					RESULT = s.getTipo();
				}else{
					if(reportar){
						parser.agregarError("Semantico",a,"Error: No existe una funcion con el nombre \""+a+"\" y parametros", aright+1, aleft+1);
					}
				}
	:};


parametros ::= 
	 parametros:ar COMA valor_operacion:r {:
				ArrayList<Simbolo> params = ar;
				if(r!=null){
					Simbolo s = (Simbolo)r;
					params.add(s);
				}
				RESULT = params;
	:}
    |valor_operacion:r {:
				ArrayList<Simbolo> params = new ArrayList<>();
				if(r!=null){
					Simbolo s = (Simbolo)r;
					params.add(s);
				}
				
				RESULT = params;
	:};

state_params ::= 
	 parametros:r {:RESULT = r;:}
    | {:ArrayList<Simbolo> params = new ArrayList<>();:};

struct_llamada_arreglo ::= 
	 IDENTIFICADOR dim_arreglo;

/*------------------------------------------------------------------------------TIPO DE DATOS*/

tipo_dato ::=	 
	 DOBLE {:RESULT = "DOBLE";:}
	|ENTERO {:RESULT = "ENTERO";:}
	|CARACTER_RSV {:RESULT = "CARACTER";:}
	|CADENA_RSV {:RESULT = "CADENA";:}
	|BOOLEAN {:RESULT = "BOOLEAN";:};


/*------------------------------------------------------------------------------ESTRUCTURA LOGICA*/

struct_operador_logico ::=	 
	 struct_operador_logico:r1 OR:o struct_operador_logico:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("BOOLEAN") || s2.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoOR(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica entre \"||\", las operaciones no son racionales, o no son booleanos", oright+1, oleft+1);
					}
				} 
				RESULT = sr;
	:}
	|struct_operador_logico:r1 NOR:o struct_operador_logico:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("BOOLEAN") || s2.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoNOR(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica entre \"!||\", las operaciones no son racionales, o no son booleanos", oright+1, oleft+1);
					}
				} 
				RESULT = sr;
	:}
	|struct_operador_logico:r1 XOR:o struct_operador_logico:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("BOOLEAN") || s2.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoXOR(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica entre \"&|\", las operaciones no son racionales, o no son booleanos", oright+1, oleft+1);
					}
				} 
				RESULT = sr;
	:}
	|struct_operador_logico:r1 AND:o struct_operador_logico:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("BOOLEAN") || s2.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoAND(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica entre \"&&\", las operaciones no son racionales, o no son booleanos", oright+1, oleft+1);
					}
				} 
				RESULT = sr;
	:}
	|struct_operador_logico:r1 NAND:o struct_operador_logico:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("BOOLEAN") || s2.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoNAND(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica entre \"!&&\", las operaciones no son racionales, o no son booleanos", oright+1, oleft+1);
					}
				} 
				RESULT = sr;
	:}
	|NOT:o PA_A struct_operador_logico:r1 PA_C {:
				Simbolo s1 = r1;
				Simbolo sr = null;
				if(reportar && (s1!=null)){
					if((s1.getTipo().equals("BOOLEAN"))){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opLogicoNOT(s1));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion logica \"!\", las operacion no es racional, o no es booleana", oright+3, oleft+3);
					}
				} 
				RESULT = sr;
	:}
	|struct_operador_relacional:r {:RESULT = (Simbolo) r;:}
	|valor_operacion:r {:RESULT = (Simbolo) r;:} ;

state_op_logicos::= OR | NOR | XOR | AND | NAND;

struct_operador_relacional ::=	 
	 valor_operacion:v1 IGUAL_IGUAL:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(s1.getTipo().equals(s2.getTipo())){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalIgualIgual(s1,s2));
					}else if (s1.getTipo().equals("CARACTER") && s1.getTipo().equals("ENTERO")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalIgualIgual(s1,s2));
					}else if(s1.getTipo().equals("ENTERO") && s1.getTipo().equals("CARACTER")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalIgualIgual(s1,s2));
					}else if (s1.getTipo().equals("DOBLE") && s1.getTipo().equals("ENTERO")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalIgualIgual(s1,s2));
					}else if(s1.getTipo().equals("ENTERO") && s1.getTipo().equals("DOBLE")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalIgualIgual(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \"==\", estos tipos de datos no puedens ser comparados", oright+1, oleft+1);
					}
				}
	:}
	|valor_operacion:v1 DIFERENTE:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(s1.getTipo().equals(s2.getTipo())){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalDiferente(s1,s2));
					}else if (s1.getTipo().equals("CARACTER") && s1.getTipo().equals("ENTERO")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalDiferente(s1,s2));
					}else if(s1.getTipo().equals("ENTERO") && s1.getTipo().equals("CARACTER")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalDiferente(s1,s2));
					}else if (s1.getTipo().equals("DOBLE") && s1.getTipo().equals("ENTERO")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalDiferente(s1,s2));
					}else if(s1.getTipo().equals("ENTERO") && s1.getTipo().equals("DOBLE")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalDiferente(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \"!=\", estos tipos de datos no puedens ser comparados", oright+1, oleft+1);
					}
				}
	:}
	|valor_operacion:v1 MAYOR_Q:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalMayorQ(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \">\", es posible realizarlo entre cadenas", oright+1, oleft+1);
					}
				}
	:}
	|valor_operacion:v1 MENOR_Q:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalMenorQ(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \"<\", es posible realizarlo entre cadenas", oright+1, oleft+1);
					}
				}
				
	:}
	|valor_operacion:v1 MAYOR_IGUAL:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalMayorQIgual(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \">=\", es posible realizarlo entre cadenas", oright+1, oleft+1);
					}
				}
	:}
	|valor_operacion:v1 MENOR_IGUAL:o valor_operacion:v2 {:
				Simbolo s1 = (Simbolo) v1;
				Simbolo s2 = (Simbolo) v2;
				Simbolo sr = null;
				if(reportar && s1!=null && s2!=null){
					if(!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA")){
						sr = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag, comprobacionTipos.opRacionalMenorQIgual(s1,s2));
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional entre \"<=\", es posible realizarlo entre cadenas", oright+1, oleft+1);
					}
				}
	:}
	|IS_NULL:o valor_operacion:v1 {:
				Simbolo s1 = (Simbolo) v1;
				if(reportar && s1!=null){
					if(s1.getTipo().equals("BOOLEAN")){
						s1.setObjeto(!((boolean)s1.getObjeto()));
						RESULT = s1;
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional, no es un valor booleano", v1right+1, v1left+1);
					}
				}
	:}
	|IS_NULL:o struct_operador_relacional:v1 {:
				Simbolo s1 = (Simbolo) v1;
				if(reportar && s1!=null){
					if(s1.getTipo().equals("BOOLEAN")){
						s1.setObjeto(!((boolean)s1.getObjeto()));
						RESULT = s1;
					}else{
						parser.agregarError("Semantico",(String) o,"Error en la operacion racional, no es un valor booleano", v1right+1, v1left+1);
					}
				}
	:}
	|PA_A struct_operador_relacional:r1 PA_C {: RESULT=r1; :};
								
state_op_racional ::==  IGUAL_IGUAL | DIFERENTE | MAYOR_Q | MENOR_Q | MAYOR_IGUAL | MENOR_IGUAL;

/*------------------------------------------------------------------------------VALOR OPERACIONAL*/

valor_operacion ::=	 
	 valor_operacion:r1 MAS:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("CADENA") || s2.getTipo().equals("CADENA"))){
						sr = new Simbolo("CADENA","CADENA",manejadorTablaSimbolos.ambitoFlag,(String) s1.getObjeto()+""+(String)s2.getObjeto() );
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(((int)s1.getObjeto().toString().charAt(0))+(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s1.getObjeto())+((int)s1.getObjeto().toString().charAt(0)));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s2.getObjeto())+(int)s2.getObjeto());
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())+(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"+\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 MENOS:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"-\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(((int)s1.getObjeto().toString().charAt(0))-(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s1.getObjeto())-((int)s1.getObjeto().toString().charAt(0)));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s2.getObjeto())-(int)s2.getObjeto());
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())-(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"-\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 POR:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"*\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double)(((int)s1.getObjeto().toString().charAt(0))*(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)((int)s1.getObjeto())*((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)((int)s2.getObjeto())*(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())*(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"*\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 DIVISION:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"/\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double)(((int)s1.getObjeto().toString().charAt(0))/(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto())/((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s2.getObjeto())/(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((double)s2.getObjeto())/(double)s2.getObjeto()));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"/\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 MODULO:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"%\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto().toString().charAt(0))%(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto())%((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, (((int)s2.getObjeto())%(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((double)s2.getObjeto())%(double)s2.getObjeto()));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"%\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 POTENCIA:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"^\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) ((Math.pow((int)s1.getObjeto().toString().charAt(0),(int)s2.getObjeto()))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((int)s1.getObjeto(),((int)s1.getObjeto().toString().charAt(0)))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((int)s2.getObjeto(),(int)s2.getObjeto())));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((double)s2.getObjeto(),(double)s2.getObjeto())));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"^\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|PA_A valor_operacion:r PA_C {:RESULT = r;:}
	|valor:r  {:RESULT = r;:};


struc_asig_var ::= 	 
	 IDENTIFICADOR IGUAL struct_operador_logico
	|IDENTIFICADOR MAS_IGUAL struct_operador_logico
	|IDENTIFICADOR MAS_MAS
	|IDENTIFICADOR MENOS_MENOS
	|IDENTIFICADOR error struct_operador_logico;

/*------------------------------------------------------------------------------Estructura arreglo*/

struct_declaracion_array ::= 
	 struct_declaracion_array:r COMA IDENTIFICADOR:a dim_arreglo:d {:
				if(reportar && r!=null && d!=null){
					ArrayList<Integer> dimens = (ArrayList<Integer>) d;
					Simbolo sr = (Simbolo) r;
					Simbolo s = new Simbolo(a,sr.getTipo(),manejadorTablaSimbolos.ambitoFlag,new Arreglo(sr.getTipo(),dimens),sr.isIsKeep(),true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:}
	|struct_declaracion_array:r COMA IDENTIFICADOR:a {:
				if(reportar && r!=null){
					Simbolo sr = (Simbolo) r;
					Simbolo s = new Simbolo(a,sr.getTipo(),manejadorTablaSimbolos.ambitoFlag,new Arreglo(sr.getTipo()),sr.isIsKeep(),true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:}
	|struct_declaracion_array:r COMA IDENTIFICADOR:a dim_arreglo:d IGUAL LLAVE_A valor_arreglo:vs LLAVE_C {:
				if(reportar && r!=null && d!=null && vs!=null){
					ArrayList<Integer> dimens = (ArrayList<Integer>) d;
					ArrayList<Object> lista = (ArrayList<Object>) vs;
					Simbolo sr = (Simbolo) r;
					Simbolo s = new Simbolo(a,sr.getTipo(),manejadorTablaSimbolos.ambitoFlag,new Arreglo(sr.getTipo(),dimens),sr.isIsKeep(),true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(manejadorArreglos.verificarDimArreglo(lista)){
							if(manejadorArreglos.compararDims(dimens)){
								Arreglo arrAux = (Arreglo) s.getObjeto();
								arrAux.llenarArreglo(manejadorArreglos.listaObj);
								s.setObjeto(arrAux);
								manejadorTablaSimbolos.agregarSimbolo(s);
							}else{
								parser.agregarError("Semantico",a,"Error: no coinciden las dimensiones del arreglo \""+a+"\" con las dimensiones de los datos que se agregaron", dright+1, dleft+1);
							}
						}else{
							parser.agregarError("Semantico",a,"Error: no coinciden las dimensiones de los valores del arreglo \""+a+"\" con los datos de se le ingresaron", vsright+1, vsleft+1);
						}
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:}
	|keep_state:k VAR tipo_dato:t ARREGLO IDENTIFICADOR:a dim_arreglo:d IGUAL LLAVE_A valor_arreglo:vs LLAVE_C {:
				if(reportar && d!=null && vs!=null){
					ArrayList<Integer> dimens = (ArrayList<Integer>) d;
					ArrayList<Object> lista = (ArrayList<Object>) vs;
					Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,new Arreglo(t,dimens),k,true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(manejadorArreglos.verificarDimArreglo(lista)){
							if(manejadorArreglos.compararDims(dimens)){
								Arreglo arrAux = (Arreglo) s.getObjeto();
								arrAux.llenarArreglo(manejadorArreglos.listaObj);
								s.setObjeto(arrAux);
								manejadorTablaSimbolos.agregarSimbolo(s);
							}else{
								parser.agregarError("Semantico",a,"Error: no coinciden las dimensiones del arreglo \""+a+"\" con las dimensiones de los datos que se agregaron", dright+1, dleft+1);
							}
						}else{
							parser.agregarError("Semantico",a,"Error: no coinciden las dimensiones de los valores del arreglo \""+a+"\" con los datos de se le ingresaron", vsright+1, vsleft+1);
						}
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:}
	|keep_state:k VAR tipo_dato:t ARREGLO IDENTIFICADOR:a {:
				if(reportar){
					//ArrayList<Integer> dimens = (ArrayList<Integer>) d;
					Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,new Arreglo(t),k,true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:}
	|keep_state:k VAR tipo_dato:t ARREGLO IDENTIFICADOR:a dim_arreglo:d {:
				if(reportar && d!=null){
					ArrayList<Integer> dimens = (ArrayList<Integer>) d;
					Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,new Arreglo(t,dimens),k,true);
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					RESULT = s;
				}
	:};

struct_declaracion_array_f ::= 
	 struct_declaracion_array_f COMA IDENTIFICADOR dim_arreglo
	|struct_declaracion_array_f COMA IDENTIFICADOR
	|struct_declaracion_array_f COMA IDENTIFICADOR dim_arreglo IGUAL LLAVE_A valor_arreglo LLAVE_C
	|VAR tipo_dato ARREGLO IDENTIFICADOR dim_arreglo IGUAL LLAVE_A valor_arreglo LLAVE_C
	|VAR tipo_dato ARREGLO IDENTIFICADOR
	|VAR tipo_dato ARREGLO IDENTIFICADOR dim_arreglo;

/*------------------------------------------------------------------------------TAMANIO ARREGLO*/

dim_arreglo ::=	 
	 dim_arreglo:r CORCHETE_A valor_operacion:v CORCHETE_C {:
				ArrayList<Integer> lista = (ArrayList<Integer>) r;
				if(reportar && v!=null){
					Simbolo s = (Simbolo) v;
					if(s.getTipo().equals("ENTERO") || s.getTipo().equals("DOBLE")){
						lista.add((int)s.getObjeto());
					}else{
						parser.agregarError("Semantico","[<numeric>]","Error: el valor de la dimesion no es numerico", vright+1, vleft+1);
					}
				}
				RESULT = lista;
	:}
	|CORCHETE_A valor_operacion:v CORCHETE_C {:
				ArrayList<Integer> lista = new ArrayList<>();
				if(reportar && v!=null){
					Simbolo s = (Simbolo) v;
					if(s.getTipo().equals("ENTERO") || s.getTipo().equals("DOBLE")){
						lista.add((int)s.getObjeto());
					}else{
						parser.agregarError("Semantico","[<numeric>]","Error: el valor de la dimesion no es numerico", vright+1, vleft+1);
					}
				}
				RESULT = lista;
	:};


/*------------------------------------------------------------------------------VALORES ARREGLO*/

valor_arreglo ::=	
	 valores_array_mas_dim:r {:RESULT = r;:} 
	|valores_array:r {:RESULT = r;:};

valores_array_mas_dim ::= 
	 LLAVE_A valores_array_mas_dim:v LLAVE_C {:
				ArrayList<Object> lista = new ArrayList<>();
				if(reportar && v!=null){
					ArrayList<Object> listaR = (ArrayList<Object>) v;
					lista.add(listaR);
				}
				RESULT = lista;
	:}
	|valores_array_mas_dim:v1 COMA LLAVE_A valores_array_mas_dim:v2 LLAVE_C {:
				ArrayList<Object> lista = (ArrayList<Object>) v1;
				//ArrayList<Object> listaR = (ArrayList<Object>) v2;
				if(reportar && v1!=null && v2!=null){
					ArrayList<Object> listaR = (ArrayList<Object>) v2;
					lista.add(listaR);
				}
				RESULT = lista;
	:}
	|LLAVE_A valores_array:v LLAVE_C {:
				if(reportar && v!=null){
					ArrayList<Object> lista = (ArrayList<Object>) v;
					RESULT = lista;
				}
				
	:}
	|valores_array_mas_dim:v1 COMA LLAVE_A valores_array:v2 LLAVE_C {:
				ArrayList<Object> lista = (ArrayList<Object>) v1;
				//ArrayList<Object> listaR = (ArrayList<Object>) v2;
				if(reportar && v1!=null && v2!=null){
					ArrayList<Object> listaR = (ArrayList<Object>) v2;
					lista.add(listaR);
				}
				RESULT = lista;
	:};

valores_array ::=  	 
	 valores_array:r COMA tipo_valor_op_logico:v {:
				ArrayList<Object> listaR = (ArrayList<Object>) r;
				if(reportar && v!=null){
					Simbolo s1 = (Simbolo) v;
					// listaR.add(s1.getObjeto());
					listaR.add(s1);
				}
				RESULT = listaR;
	:}
	|tipo_valor_op_logico:v {:
				ArrayList<Object> lista = new ArrayList<>();
				if(reportar && v!=null){
					Simbolo s1 = (Simbolo) v;
					// lista.add(s1.getObjeto());
					lista.add(s1);
				}
				RESULT = lista;
	:};

// tipo_valor_op_logico ::= struct_operador_logico
// 						|valor_operacion;

tipo_valor_op_logico ::= struct_operador_logico;

/*------------------------------------------------------------------------------ESTRUCTURA ASIGNACION VALORES ARREGLO*/

struct_asig_arreglo ::=  
	IDENTIFICADOR dim_arreglo IGUAL tipo_valor_op_logico;

/*------------------------------------------------------------------------------STRUCUTRA DE UNA FUNCION*/

struct_funcion ::=	 
	 tipo_dato:t IDENTIFICADOR:a PA_A struct_parametros:p PA_C {:
	 			Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,(ArrayList<Simbolo>) p,false,true,false);
				 s.generarParamsStrings();
				if(reportar){
					s.generarParamsStrings();
					if(manejadorTablaSimbolos.isExistSimboloFM(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un metodo o funcion con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				reportar = false;
	:} st_ind code_funcion st_ded {:reportar = true;:}
	|KEEP tipo_dato:t IDENTIFICADOR:a PA_A struct_parametros:p PA_C {:
	 			Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,(ArrayList<Simbolo>) p,true,true,false);
				 s.generarParamsStrings();
				if(reportar){
					s.generarParamsStrings();
					if(manejadorTablaSimbolos.isExistSimboloFM(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un metodo o funcion con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				reportar = false;
	:} st_ind code_funcion st_ded {:reportar = true;:};

struct_procedimiento ::= 
	 IDENTIFICADOR:a PA_A struct_parametros:p PA_C {:
	 			Simbolo s = new Simbolo(a,"PROCEDIMIETO",manejadorTablaSimbolos.ambitoFlag,(ArrayList<Simbolo>) p,false,false,true);
				s.generarParamsStrings();
				if(reportar){
					s.generarParamsStrings();
					if(manejadorTablaSimbolos.isExistSimboloFM(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un metodo o funcion con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				reportar = false;
	:} st_ind code_metodo st_ded  {:reportar = true;:}
	|KEEP IDENTIFICADOR:a PA_A struct_parametros:p PA_C {:
	 			Simbolo s = new Simbolo(a,"PROCEDIMIETO",manejadorTablaSimbolos.ambitoFlag,(ArrayList<Simbolo>) p,true,false,true);
				s.generarParamsStrings();
				if(reportar){
					s.generarParamsStrings();
					if(manejadorTablaSimbolos.isExistSimboloFM(s)){
						manejadorTablaSimbolos.agregarSimbolo(s);
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un metodo o funcion con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				reportar = false;
	:} st_ind code_metodo st_ded {:reportar = true;:};


struct_parametros ::=
	 params_lleno:r {:RESULT = r;:}
	|param_vacio:r  {:RESULT = r;:} ;

params_lleno ::= 
	 struct_parametros:r COMA tipo_dato:t IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambito+1);
				ArrayList<Simbolo> lista = (ArrayList<Simbolo>)r;
				lista.add(s);
				RESULT = lista;
	:}
	|tipo_dato:t IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambito+1);
				ArrayList<Simbolo> lista = new ArrayList<>();
				lista.add(s);
				RESULT = lista;
	:} ;

param_vacio ::= {:ArrayList<Simbolo> lista = new ArrayList<>(); RESULT = lista;:};

code_funcion ::=
	 struct_declaracion_var_f code_funcion
	|struc_asig_var code_funcion
	|struct_declaracion_array_f  code_funcion
	|struct_asig_arreglo code_funcion
	|strunt_llamada_funcion code_funcion
	|struct_si code_funcion
    |struct_switch code_funcion
    |struct_para code_funcion
    |struct_mientras code_funcion
    |struct_hacer code_funcion
    |struct_reproducir code_funcion
    |struct_esperar code_funcion
    |struct_ordenar code_funcion
    |struct_sumarizar code_funcion
    |struct_longitud code_funcion
	|struct_mensaje code_funcion
	|RETORNAR struct_operador_logico code_funcion
	|RETORNAR error
	|;

code_metodo ::=
	 struct_declaracion_var_f code_metodo
	|struc_asig_var code_metodo
	|struct_declaracion_array_f  code_metodo
	|struct_asig_arreglo code_metodo
	|strunt_llamada_funcion code_metodo
	|struct_si code_metodo
    |struct_switch code_metodo
    |struct_para code_metodo
    |struct_mientras code_metodo
    |struct_hacer code_metodo
    |struct_reproducir code_metodo
    |struct_esperar code_metodo
    |struct_ordenar code_metodo
    |struct_sumarizar code_metodo
    |struct_longitud code_metodo
    |struct_mensaje code_metodo
	|;


/*------------------------------------------------------------------------------Funciones reservadas*/

struct_reproducir ::= 
	 REPRODUCIR PA_A notas COMA valor_operacion COMA valor_operacion COMA valor_operacion PA_C;

struct_esperar ::= 
	 ESPERAR PA_A valor_operacion COMA valor_operacion PA_C;

struct_ordenar ::= 
	 ORDENAR PA_A IDENTIFICADOR COMA tipo_orden PA_C;

struct_sumarizar ::= 
	 SUMARIZAR PA_A IDENTIFICADOR PA_C;

struct_longitud ::= 
	 LONGITUD PA_A valor_operacion PA_C;

struct_mensaje ::= 	 
	 MENSAJE PA_A mensajes PA_C
	|MENSAJE PA_A PA_C;

mensajes ::= 
	 mensajes MAS struct_operador_logico 
	|struct_operador_logico;

/*------------------------------------------------------------------------------NOTAS MUSICALES*/

notas ::= 	 DO | RE | MI | FA | SOL | LA | SI 
			|DO_S | RE_S | FA_S | SOL_S | LA_S;

/*------------------------------------------------------------------------------OCTAVAS*/

//octavas ::= 
/*------------------------------------------------------------------------------TIPO DE ORDEN*/

tipo_orden ::= ASCENDENTE | DESCENDENTE | PARES | IMPARES | PRIMOS ;

/*------------------------------------------------------------------------------ORDENACION*/ 

orden_valor ::=  valor_operacion
				|valor_arreglo;

/*------------------------------------------------------------------------------STRUTURA PRINCIPAL MEOTODO*/

struct_principal ::= PRINCIPAL PA_A PA_C st_ind code_metodo st_ded;

/*------------------------------------------------------------------------------ESTRUTURA SI-SINO SI-SINO*/

struct_si ::=	
	 SI PA_A struct_operador_logico PA_C st_ind code_funcion st_ded struct_sino;

struct_sino ::=	 
	 SINO_SI PA_A struct_operador_logico PA_C st_ind code_funcion st_ded struct_sino
	|SINO st_ind code_funcion st_ded
	|;

/*------------------------------------------------------------------------------ESTRUCTURA SWITCH*/

struct_switch ::= 
	 SWITCH PA_A IDENTIFICADOR PA_C st_ind struct_caso st_ded;

struct_caso ::=  
 	 CASO valor_operacion st_ind code_funcion caso_salir st_ded struct_caso
	|DEFAULT st_ind code_funcion st_ded 
	|;

caso_salir ::=   SALIR
				|;

/*------------------------------------------------------------------------------ESTRUCTURA PARA*/

struct_para ::=	 
	 PARA PA_A para_asig_var PUNTO_COMA condicion_para PUNTO_COMA incremento_para PA_C st_ind code_funcion st_ded;

para_asig_var ::=	 
	VAR tipo_dato IDENTIFICADOR IGUAL valor_operacion
	|IDENTIFICADOR IGUAL valor_operacion;

condicion_para ::=	struct_operador_logico;

incremento_para ::=  
	 IDENTIFICADOR IGUAL valor_operacion
	|IDENTIFICADOR MAS_IGUAL valor_operacion
	|IDENTIFICADOR MAS_MAS
	|IDENTIFICADOR MENOS_MENOS;

	
/*------------------------------------------------------------------------------Estrcutura mientras, hacer-mientras, */

struct_mientras ::=	
	 MIENTRAS PA_A struct_operador_logico PA_C st_ind code_funcion st_ded;

struct_hacer ::= 
	 HACER st_ind code_funcion state_continuar st_ded MIENTRAS PA_A struct_operador_logico PA_C;

state_continuar ::=  CONTINUAR
					|;


especiales_q_retornan ::=
	 struct_reproducir {: RESULT = "ENTERO";:}
    |struct_sumarizar {: RESULT = "CADENA"; :}
    |struct_longitud {: RESULT = "ENTERO"; :};



    