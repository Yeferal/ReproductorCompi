//codigo usuario
package backend.analizador.comprobaciones.tablasimbolos;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.Stack;
import backend.analizador.objetos.*;


//Codigo para el parser, variables, metodos
parser code
{:
    //codigo
    //public ArrayList<ErrorSintactico> listaErrores = new ArrayList<>();

    public void setAccion(String tipo, String mensaje, String accion){
    }

	private Symbol s;
	public Symbol getS(Symbol s){
        return this.s = s;
    }

    public void syntax_error(Symbol s){
        String message = s.toString();
        StringBuilder m = new StringBuilder("Error: ");
        String cadena =  (String) s.value;
        int columna = s.left+1;
        int linea = s.right+1;
        agregarError("Sintactico",cadena,"No se esperaba un token tipo <"+s.value+">", linea, columna);
    }

	public void agregarError(String tipo, String cadena, String descripcion, int linea, int columna){
        System.out.println("Tipo: "+tipo+"\tCadena: "+cadena+", descripcion: "+descripcion+", Linea: "+linea+", Columna: "+columna);
    }


	public void unrecovered_syntax_error(Symbol cur_token){
        
        System.out.println("No se pudo recuperar y seguir analizando, no se encontraron mas tokens.");
    }

:}

//Coidgo para las acciones gramaticales

action code
{:
	public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public ManejadorTablaSimbolos manejadorTablaSimbolos = new ManejadorTablaSimbolos(tablaSimbolos);
	public ComprobacionTipos comprobacionTipos = new ComprobacionTipos();
	boolean reportar = true;
:}

//Declaraciones 
//terminal COMENTARIO_LINEA, COMENTARIO_BLOQUE;
terminal PISTA;
terminal String IDENTIFICADOR;
terminal EXTIENDE, COMA, PUNTO_COMA;
terminal ENTERO, DOBLE, BOOLEAN, CARACTER_RSV, CADENA_RSV;
terminal IGUAL_IGUAL, DIFERENTE, MAYOR_Q, MENOR_Q, MAYOR_IGUAL, MENOR_IGUAL, IS_NULL;
terminal AND, NAND, OR, NOR, XOR, NOT;
terminal MAS, MENOS, POR, DIVISION, MODULO, POTENCIA;
terminal KEEP, VAR, IGUAL;
terminal Integer NUMERO;
terminal Double DECIMAL;
terminal String CADENA;
terminal Boolean TRUE, FALSE;
terminal String CARACTER;
terminal MAS_IGUAL, MAS_MAS, MENOS_MENOS;
terminal ARREGLO, CORCHETE_A, CORCHETE_C, LLAVE_A, LLAVE_C;
terminal SI, SINO, PA_A, PA_C;
terminal SWITCH, CASO, SALIR, DEFAULT;
terminal PARA, MIENTRAS, HACER, CONTINUAR;
terminal RETORNAR, VOID;
terminal REPRODUCIR, ESPERAR, ORDENAR, ASCENDENTE, DESCENDENTE, PARES, IMPARES, PRIMOS;
terminal SUMARIZAR, LONGITUD, MENSAJE, PRINCIPAL;
terminal DO, RE, MI, FA, SOL, LA, DO_S, RE_S, FA_S, SOL_S, LA_S, SINO_SI;
terminal INDENT, DEDENT;


// declaracion no terminales
//non terminal String INICIO, blanco, comentarios, codigo, struct_pista, struct_extiende;
non terminal  INICIO, blanco, codigo, struct_pista, struct_extiende;
non terminal  extiende_state, struc_code, struct_declaracion_var;
non terminal Boolean keep_state;
non terminal  valor_declaracion_operacion;
non terminal Simbolo valor, struc_asig_var;
non terminal String tipo_dato;
non terminal Simbolo struct_operador_logico;
non terminal Simbolo valor_operacion;
non terminal struct_declaracion_array;
non terminal  dim_arreglo, valor_arreglo, valores_array;
non terminal  struct_si, struct_sino, struct_switch;
non terminal  state_tab, struct_asig_arreglo;
non terminal  struct_para, struct_mientras;
non terminal  struct_hacer, struct_funcion, struct_procedimiento, struct_reproducir;
non terminal  struct_esperar, struct_ordenar, struct_sumarizar, struct_longitud;
non terminal  struct_mensaje, struct_principal;
non terminal  strunt_llamada_funcion, struct_llamada_arreglo;
non terminal ArrayList<String> parametros, state_params;
non terminal  para_asig_var, condicion_para, incremento_para, struct_parametros;
non terminal  notas, tipo_orden, struct_operador_relacional;
non terminal  tipo_valor_op_logico, mensajes;
non terminal  st_ind, st_ded, st_final, code_funcion, code_metodo, caso_salir, state_continuar, struct_caso ;
non terminal params_lleno, param_vacio, valores_array_mas_dim, especiales_q_retornan;
non terminal state_op_logicos, state_op_racional;
/*non terminal ;
*/


//presedencia de menor a mayor
//Precediencia operadores logicos
precedence left OR, NOR, XOR;
precedence left AND, NAND;
precedence right NOT;

//Presedencia operadores matematicos
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR_Q, MENOR_Q, MAYOR_IGUAL, MENOR_IGUAL;
precedence left MAS, MENOS;
precedence left MODULO, DIVISION, POR;
precedence left POTENCIA;



start with INICIO;

//Reglas Semanticas


INICIO ::= blanco codigo;

/*------------------------------------------------------------------------------LO QUE VENGA AL INICIO*/
// blanco ::= 	 comentarios blanco
// 			|INDENT blanco DEDENT blanco
//             |;

blanco ::= 	 INDENT blanco DEDENT blanco
            |;

/*------------------------------------------------------------------------------ESTADOS DE INDENT y DEDENT*/

st_ind ::=   INDENT {:manejadorTablaSimbolos.indent();:};

st_ded ::=   DEDENT {:manejadorTablaSimbolos.dedent();:};

st_final ::= DEDENT
            |;

/*------------------------------------------------------------------------------COMENTARIOS*/

// comentarios ::=  COMENTARIO_LINEA
// 				|COMENTARIO_BLOQUE;

/*------------------------------------------------------------------------------CODIGO PISTA*/
codigo ::= 	 struct_pista codigo
            |;

/*------------------------------------------------------------------------------ESTRUCTURA DE PISTA*/

struct_pista ::= 
	 PISTA IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,"PISTA",manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.isExistSimbolo(s)){
					manejadorTablaSimbolos.agregarSimbolo(s);
				}else{
					parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
				}
	:} extiende_state st_ind struc_code st_final;

/*------------------------------------------------------------------------------ESTADO EXTIENDE O NO*/

extiende_state ::= 	 struct_extiende
					|;

/*------------------------------------------------------------------------------ESTRUCTURA EXTIENDE*/

struct_extiende ::=  struct_extiende COMA IDENTIFICADOR
					|EXTIENDE IDENTIFICADOR;

struc_code ::=	 struct_declaracion_var struc_code
				|struct_declaracion_array  struc_code
                |struct_funcion struc_code
                |struct_procedimiento struc_code
                |struct_principal struc_code
				|;

/*------------------------------------------------------------------------------ESTRUCTURA DE DECLARACION DE VARIABLES*/

struct_declaracion_var ::=	 
	 struct_declaracion_var:ss COMA IDENTIFICADOR:a {:
				Simbolo sAux =(Simbolo) ss;
				Simbolo s = new Simbolo(a,sAux.getTipo(),manejadorTablaSimbolos.ambitoFlag,sAux.isIsKeep());
				if(manejadorTablaSimbolos.isExistSimbolo(s)){
					manejadorTablaSimbolos.agregarSimbolo(s);
				}else{
					parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
				}
				RESULT = s;
	:}
	|struct_declaracion_var:r COMA IDENTIFICADOR:a IGUAL struct_operador_logico:vr {:
				Simbolo s = null;
				Simbolo sr1 = (Simbolo) r;
				Simbolo sr = (Simbolo) vr;
				if(reportar && vr!=null){
					s = new Simbolo(a,sr1.getTipo(),manejadorTablaSimbolos.ambitoFlag,sr1.isIsKeep());
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(comprobacionTipos.getTipoDato(sr1.getTipo(),sr.getTipo())!=null ){
							s.setObjeto(comprobacionTipos.convertir(vr.getObjeto(),sr.getTipo()));
							manejadorTablaSimbolos.agregarSimbolo(s);
						}else{
							parser.agregarError("Semantico",a,"Error: no es posible asignar el valor a la varible nombre \""+a+"\", ya que no es del mismo tipo dato", vrright+1, vrleft+1);
						}
						
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				RESULT = s;
	:}
	|keep_state:k VAR tipo_dato:t IDENTIFICADOR:a IGUAL struct_operador_logico:vr {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,k);
				Simbolo sr = (Simbolo) vr;
				if(reportar && vr!=null){
					if(manejadorTablaSimbolos.isExistSimbolo(s)){
						if(comprobacionTipos.getTipoDato(s.getTipo(),sr.getTipo())!=null ){
							s.setObjeto(comprobacionTipos.convertir(sr.getObjeto(),sr.getTipo()));
							manejadorTablaSimbolos.agregarSimbolo(s);
						}else{
							parser.agregarError("Semantico",a,"Error: no es posible asignar el valor a la varible nombre \""+a+"\", ya que no es del mismo tipo dato", vrright+1, vrleft+1);
						}
						
					}else{
						parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
				}
				RESULT = s;
	:}
	|keep_state:k VAR tipo_dato:t IDENTIFICADOR:a {:
				Simbolo s = new Simbolo(a,t,manejadorTablaSimbolos.ambitoFlag,k);
				if(manejadorTablaSimbolos.isExistSimbolo(s)){
					manejadorTablaSimbolos.agregarSimbolo(s);
				}else{
					parser.agregarError("Semantico",a,"Error: Ya existe un simbolo con el mismo nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
				}
				RESULT = s;
	:};

/*------------------------------------------------------------------------------ESTADO KEEP*/

keep_state ::=   KEEP {:RESULT = true;:}
                | {:RESULT = false;:};

/*------------------------------------------------------------------------------VALORES DE DATOS*/

valor ::=	 
	 IDENTIFICADOR:a {:
	 			Simbolo s = new Simbolo(a,manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.buscarSimbolo(s)){
					s = manejadorTablaSimbolos.getSimbolo();
					RESULT = s;
				}else{
					if(reportar){
						parser.agregarError("Semantico",a,"Error: No existe un simbolo con el nombre \""+a+"\" dentro del ambito", aright+1, aleft+1);
					}
					
				}
	:}
	|strunt_llamada_funcion:r {:RESULT = (Simbolo) r;:}
	|struct_llamada_arreglo:r {:RESULT = (Simbolo) r;:}
	|especiales_q_retornan:r {:RESULT = (Simbolo) r;:}
	|NUMERO:a {:
			Simbolo s = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(Integer)a);
			RESULT = s;
	:}
	|DECIMAL:a {:
			Simbolo s = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(Double)a);
			RESULT = s;
	:}
	|CADENA:a {:
			Simbolo s = new Simbolo("CADENA","CADENA",manejadorTablaSimbolos.ambitoFlag,(String)a);
			RESULT = s;
	:}
	|CARACTER:a {:
			Simbolo s = new Simbolo("CARACTER","CARACTER",manejadorTablaSimbolos.ambitoFlag,a);
			RESULT = s;
	:}
	|TRUE {:
			Simbolo s = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag,true);
			RESULT = s;
	:}
	|FALSE {:
			Simbolo s = new Simbolo("BOOLEAN","BOOLEAN",manejadorTablaSimbolos.ambitoFlag,false);
			RESULT = s;
	:};

strunt_llamada_funcion ::= 
	 IDENTIFICADOR:a PA_A state_params:p PA_C {:
	 			Simbolo s = new Simbolo(a,manejadorTablaSimbolos.ambitoFlag);
				if(manejadorTablaSimbolos.buscarSimboloFuncionMetodo(s,"FUNCION")){
					s = manejadorTablaSimbolos.getSimbolo();
					RESULT = s.getTipo();
				}else{
					if(reportar){
						parser.agregarError("Semantico",a,"Error: No existe una funcion con el nombre \""+a+"\" y parametros", aright+1, aleft+1);
					}
				}
	:};


parametros ::= 
	 parametros:ar COMA valor_operacion:r {:
				ArrayList<String> params = ar;
				if(r!=null){
					Simbolo s = (Simbolo)r;
					params.add(s.getTipo());
				}
				RESULT = params;
	:}
    |valor_operacion:r {:
				ArrayList<String> params = new ArrayList<>();
				if(r!=null){
					Simbolo s = (Simbolo)r;
					params.add(s.getTipo());
				}
				
				RESULT = params;
	:};

state_params ::= 
	 parametros:r {:RESULT = r;:}
    | {:ArrayList<String> params = new ArrayList<>();:};

struct_llamada_arreglo ::= 
	 IDENTIFICADOR dim_arreglo;

/*------------------------------------------------------------------------------TIPO DE DATOS*/

tipo_dato ::=	 
	 DOBLE {:RESULT = "DOBLE";:}
	|ENTERO {:RESULT = "ENTERO";:}
	|CARACTER_RSV {:RESULT = "CARACTER";:}
	|CADENA_RSV {:RESULT = "CADENA";:}
	|BOOLEAN {:RESULT = "BOOLEAN";:};


/*------------------------------------------------------------------------------ESTRUCTURA LOGICA*/

struct_operador_logico ::=	 
	 struct_operador_logico OR struct_operador_logico {::}
	|struct_operador_logico NOR struct_operador_logico {::}
	|struct_operador_logico XOR struct_operador_logico {::}
	|struct_operador_logico AND struct_operador_logico {::}
	|struct_operador_logico NAND struct_operador_logico {::}
	|NOT PA_A struct_operador_logico PA_C {::}
	|struct_operador_relacional:r {:RESULT = (Simbolo) r;:}
	|valor_operacion:r {:RESULT = r;:} ;

state_op_logicos::= OR | NOR | XOR | AND | NAND;

struct_operador_relacional ::=	 
	 valor_operacion IGUAL_IGUAL valor_operacion {::}
	|valor_operacion DIFERENTE valor_operacion {::}
	|valor_operacion MAYOR_Q valor_operacion {::}
	|valor_operacion MENOR_Q valor_operacion {::}
	|valor_operacion MAYOR_IGUAL valor_operacion {::}
	|valor_operacion MENOR_IGUAL valor_operacion {::}
	|IS_NULL valor_operacion {::};
								
state_op_racional ::==  IGUAL_IGUAL | DIFERENTE | MAYOR_Q | MENOR_Q | MAYOR_IGUAL | MENOR_IGUAL;

/*------------------------------------------------------------------------------VALOR OPERACIONAL*/

valor_operacion ::=	 
	 valor_operacion:r1 MAS:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((s1.getTipo().equals("CADENA") || s2.getTipo().equals("CADENA"))){
						sr = new Simbolo("CADENA","CADENA",manejadorTablaSimbolos.ambitoFlag,(String) s1.getObjeto()+""+(String)s2.getObjeto() );
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(((int)s1.getObjeto().toString().charAt(0))+(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s1.getObjeto())+((int)s1.getObjeto().toString().charAt(0)));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s2.getObjeto())+(int)s2.getObjeto());
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())+(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"+\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 MENOS:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"-\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag,(((int)s1.getObjeto().toString().charAt(0))-(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s1.getObjeto())-((int)s1.getObjeto().toString().charAt(0)));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("ENTERO","ENTERO",manejadorTablaSimbolos.ambitoFlag, ((int)s2.getObjeto())-(int)s2.getObjeto());
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())-(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"-\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 POR:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"*\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double)(((int)s1.getObjeto().toString().charAt(0))*(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)((int)s1.getObjeto())*((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)((int)s2.getObjeto())*(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, ((double)s2.getObjeto())*(double)s2.getObjeto());
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"*\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 DIVISION:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"/\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double)(((int)s1.getObjeto().toString().charAt(0))/(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto())/((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s2.getObjeto())/(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((double)s2.getObjeto())/(double)s2.getObjeto()));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"/\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 MODULO:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"%\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto().toString().charAt(0))%(int)s2.getObjeto()));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((int)s1.getObjeto())%((int)s1.getObjeto().toString().charAt(0))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag, (((int)s2.getObjeto())%(int)s2.getObjeto()));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (((double)s2.getObjeto())%(double)s2.getObjeto()));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"%\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|valor_operacion:r1 POTENCIA:o valor_operacion:r2 {:
				Simbolo s1 = r1;
				Simbolo s2 = r2;
				Simbolo sr = null;
				if(reportar && (s1!=null && s2!=null)){
					if((!s1.getTipo().equals("CADENA") && !s2.getTipo().equals("CADENA"))){
						parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"^\", no es posible realizar esta operacion entre cadenas", oright+1, oleft+1);
					}else{
						if(s1.getTipo().equals("CARACTER") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) ((Math.pow((int)s1.getObjeto().toString().charAt(0),(int)s2.getObjeto()))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("CARACTER")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((int)s1.getObjeto(),((int)s1.getObjeto().toString().charAt(0)))));
						}else if(s1.getTipo().equals("ENTERO") && s2.getTipo().equals("ENTERO")){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((int)s2.getObjeto(),(int)s2.getObjeto())));
						}else if((s1.getTipo().equals("ENTERO") && s2.getTipo().equals("DOBLE")) || (s1.getTipo().equals("DOBLE") && s2.getTipo().equals("ENTERO"))){
							sr = new Simbolo("DOBLE","DOBLE",manejadorTablaSimbolos.ambitoFlag,(double) (Math.pow((double)s2.getObjeto(),(double)s2.getObjeto())));
						}else{
							parser.agregarError("Semantico",(String) o,"Error en la operacion entre \"^\"", oright+1, oleft+1);
						}
					}
				}
				RESULT = sr;
	:}
	|PA_A valor_operacion:r PA_C {:RESULT = r;:}
	|valor:r  {:RESULT = r;:};


struc_asig_var ::= 	 
	 IDENTIFICADOR IGUAL struct_operador_logico
	|IDENTIFICADOR MAS_IGUAL struct_operador_logico
	|IDENTIFICADOR MAS_MAS
	|IDENTIFICADOR MENOS_MENOS
	|IDENTIFICADOR error struct_operador_logico;

/*------------------------------------------------------------------------------Estructura arreglo*/

struct_declaracion_array ::= 
	 struct_declaracion_array COMA IDENTIFICADOR dim_arreglo
	|struct_declaracion_array COMA IDENTIFICADOR
	|struct_declaracion_array COMA IDENTIFICADOR dim_arreglo IGUAL LLAVE_A valor_arreglo LLAVE_C
	|keep_state VAR tipo_dato ARREGLO IDENTIFICADOR dim_arreglo IGUAL LLAVE_A valor_arreglo LLAVE_C
	|keep_state VAR tipo_dato ARREGLO IDENTIFICADOR
	|keep_state VAR tipo_dato ARREGLO IDENTIFICADOR dim_arreglo;

/*------------------------------------------------------------------------------TAMANIO ARREGLO*/

dim_arreglo ::=	 
	 dim_arreglo CORCHETE_A valor_operacion CORCHETE_C
	|CORCHETE_A valor_operacion CORCHETE_C;


/*------------------------------------------------------------------------------VALORES ARREGLO*/

valor_arreglo ::=	
	 valores_array_mas_dim 
	|valores_array ;

valores_array_mas_dim ::= 
	 LLAVE_A valores_array_mas_dim LLAVE_C
	|valores_array_mas_dim COMA LLAVE_A valores_array_mas_dim LLAVE_C
	|LLAVE_A valores_array LLAVE_C
	|valores_array_mas_dim COMA LLAVE_A valores_array LLAVE_C;

valores_array ::=  	 
	 valores_array COMA tipo_valor_op_logico
	|tipo_valor_op_logico;

// tipo_valor_op_logico ::= struct_operador_logico
// 						|valor_operacion;

tipo_valor_op_logico ::= struct_operador_logico;

/*------------------------------------------------------------------------------ESTRUCTURA ASIGNACION VALORES ARREGLO*/

struct_asig_arreglo ::=  
	IDENTIFICADOR dim_arreglo IGUAL tipo_valor_op_logico;

/*------------------------------------------------------------------------------STRUCUTRA DE UNA FUNCION*/

struct_funcion ::=	 
	 tipo_dato IDENTIFICADOR PA_A struct_parametros PA_C {:reportar = false;:} st_ind code_funcion st_ded {:reportar = true;:}
	|KEEP tipo_dato IDENTIFICADOR PA_A struct_parametros PA_C {:reportar = false;:} st_ind code_funcion st_ded {:reportar = true;:};

struct_procedimiento ::= 
	 IDENTIFICADOR PA_A struct_parametros PA_C {:reportar = false;:} st_ind code_metodo st_ded  {:reportar = true;:}
	|KEEP IDENTIFICADOR PA_A struct_parametros PA_C {:reportar = false;:} st_ind code_metodo st_ded {:reportar = true;:};


struct_parametros ::=
	params_lleno
	|param_vacio;

params_lleno ::= 
	 struct_parametros COMA tipo_dato IDENTIFICADOR
	|tipo_dato IDENTIFICADOR;

param_vacio ::= ;

code_funcion ::=
	 struct_declaracion_var code_funcion
	|struc_asig_var code_funcion
	|struct_declaracion_array  code_funcion
	|struct_asig_arreglo code_funcion
	|strunt_llamada_funcion code_funcion
	|struct_si code_funcion
    |struct_switch code_funcion
    |struct_para code_funcion
    |struct_mientras code_funcion
    |struct_hacer code_funcion
    |struct_reproducir code_funcion
    |struct_esperar code_funcion
    |struct_ordenar code_funcion
    |struct_sumarizar code_funcion
    |struct_longitud code_funcion
	|struct_mensaje code_funcion
	|RETORNAR struct_operador_logico code_funcion
	|RETORNAR error
	|;

code_metodo ::=
	 struct_declaracion_var code_metodo
	|struc_asig_var code_metodo
	|struct_declaracion_array  code_metodo
	|struct_asig_arreglo code_metodo
	|strunt_llamada_funcion code_metodo
	|struct_si code_metodo
    |struct_switch code_metodo
    |struct_para code_metodo
    |struct_mientras code_metodo
    |struct_hacer code_metodo
    |struct_reproducir code_metodo
    |struct_esperar code_metodo
    |struct_ordenar code_metodo
    |struct_sumarizar code_metodo
    |struct_longitud code_metodo
    |struct_mensaje code_metodo
	|;


/*------------------------------------------------------------------------------Funciones reservadas*/

struct_reproducir ::= 
	 REPRODUCIR PA_A notas COMA valor_operacion COMA valor_operacion COMA valor_operacion PA_C;

struct_esperar ::= 
	 ESPERAR PA_A valor_operacion COMA valor_operacion PA_C;

struct_ordenar ::= 
	 ORDENAR PA_A IDENTIFICADOR COMA tipo_orden PA_C;

struct_sumarizar ::= 
	 SUMARIZAR PA_A IDENTIFICADOR PA_C;

struct_longitud ::= 
	 LONGITUD PA_A valor_operacion PA_C;

struct_mensaje ::= 	 
	 MENSAJE PA_A mensajes PA_C
	|MENSAJE PA_A PA_C;

mensajes ::= 
	 mensajes MAS struct_operador_logico 
	|struct_operador_logico;

/*------------------------------------------------------------------------------NOTAS MUSICALES*/

notas ::= 	 DO | RE | MI | FA | SOL | LA | SI 
			|DO_S | RE_S | FA_S | SOL_S | LA_S;

/*------------------------------------------------------------------------------OCTAVAS*/

//octavas ::= 
/*------------------------------------------------------------------------------TIPO DE ORDEN*/

tipo_orden ::= ASCENDENTE | DESCENDENTE | PARES | IMPARES | PRIMOS ;

/*------------------------------------------------------------------------------ORDENACION*/ 

orden_valor ::=  valor_operacion
				|valor_arreglo;

/*------------------------------------------------------------------------------STRUTURA PRINCIPAL MEOTODO*/

struct_principal ::= PRINCIPAL PA_A PA_C st_ind code_metodo st_ded;

/*------------------------------------------------------------------------------ESTRUTURA SI-SINO SI-SINO*/

struct_si ::=	
	 SI PA_A struct_operador_logico PA_C st_ind code_funcion st_ded struct_sino;

struct_sino ::=	 
	 SINO_SI PA_A struct_operador_logico PA_C st_ind code_funcion st_ded struct_sino
	|SINO st_ind code_funcion st_ded
	|;

/*------------------------------------------------------------------------------ESTRUCTURA SWITCH*/

struct_switch ::= 
	 SWITCH PA_A IDENTIFICADOR PA_C st_ind struct_caso st_ded;

struct_caso ::=  
 	 CASO valor_operacion st_ind code_funcion caso_salir st_ded struct_caso
	|DEFAULT st_ind code_funcion st_ded 
	|;

caso_salir ::=   SALIR
				|;

/*------------------------------------------------------------------------------ESTRUCTURA PARA*/

struct_para ::=	 
	 PARA PA_A para_asig_var PUNTO_COMA condicion_para PUNTO_COMA incremento_para PA_C st_ind code_funcion st_ded;

para_asig_var ::=	 
	VAR tipo_dato IDENTIFICADOR IGUAL valor_operacion
	|IDENTIFICADOR IGUAL valor_operacion;

condicion_para ::=	struct_operador_logico;

incremento_para ::=  
	 IDENTIFICADOR IGUAL valor_operacion
	|IDENTIFICADOR MAS_IGUAL valor_operacion
	|IDENTIFICADOR MAS_MAS
	|IDENTIFICADOR MENOS_MENOS;

	
/*------------------------------------------------------------------------------Estrcutura mientras, hacer-mientras, */

struct_mientras ::=	
	 MIENTRAS PA_A struct_operador_logico PA_C st_ind code_funcion st_ded;

struct_hacer ::= 
	 HACER st_ind code_funcion state_continuar st_ded MIENTRAS PA_A struct_operador_logico PA_C;

state_continuar ::=  CONTINUAR
					|;


especiales_q_retornan ::=
	 struct_reproducir {: RESULT = "ENTERO";:}
    |struct_sumarizar {: RESULT = "CADENA"; :}
    |struct_longitud {: RESULT = "ENTERO"; :};



    